{
  "title": "Cassandra architecture",
  "content": "<h2 style=\"font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-weight: 600; line-height: 1.2; color: rgb(38, 38, 38); margin-top: 20px; margin-bottom: 5px; font-size: 30px; clear: both; text-align: justify;\">Introduction</h2><div style=\"color: rgb(38, 38, 38); font-family: Georgia, serif; font-size: 19px; line-height: 27.55px; text-align: justify;\"><a href=\"http://java.dzone.com/articles/introduction-nosql-apache\" title=\"An Introduction To NoSQL &amp; Apache Cassandra\" rel=\"nofollow\" style=\"color: rgb(2, 136, 209); font-size: 15px; line-height: 1.45em; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;\">An Introduction To NoSQL &amp; Apache Cassandra</a><span style=\"line-height: 1.45em;\"><span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 15px;\">, introduced us to various types of NoSQL database and Apache Cassandra. In this article I am going to delve into Cassandra’s Architecture. Cassandra is a peer-to-peer distributed database that runs on a cluster of homogeneous nodes. Cassandra has been architected from the ground up to handle large volumes of data while providing high availability. Cassandra provides high write and read throughput. &nbsp;A Cassandra cluster has no special nodes i.e. the cluster has no masters, no slaves or elected leaders. This enables Cassandra to be highly available while having no single point of failure.</span></span></div><h2 style=\"font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-weight: 600; line-height: 1.2; color: rgb(38, 38, 38); margin-top: 20px; margin-bottom: 5px; font-size: 30px; clear: both;\">Key Concepts, Data Structures and Algorithms</h2><p pid=\"1\" style=\"margin-top: 5px; margin-bottom: 15px; padding-top: 0px; color: rgb(38, 38, 38); font-family: Georgia, serif; font-size: 19px; line-height: 27.55px;\">In order to understand Cassandra's architecture it is important to understand some key concepts, data structures and algorithms frequently used by Cassandra.</p><ul style=\"color: rgb(38, 38, 38); font-family: Georgia, serif; font-size: 19px; line-height: 27.55px;\"><li style=\"padding: 0px 0px 8px;\"><strong>Data Partitioning</strong>&nbsp;- &nbsp;Apache Cassandra is a distributed database system using a shared nothing architecture. A single logical database is spread across a cluster of nodes and thus the need to spread data evenly amongst all participating nodes. At a 10000 foot level Cassandra stores data by dividing data evenly around its cluster of nodes. Each node is responsible for part of the data. The act of distributing data across nodes is referred to as data partitioning.</li><li style=\"padding: 0px 0px 8px;\"><strong>Consistent Hashing</strong>&nbsp;- Two main problems crop up when trying to distribute data efficiently.<span style=\"line-height: 1.5;\">One, determining a node on which a specific piece of data should reside on.&nbsp;</span>Two, minimising data movement when adding or removing nodes. Consistent hashing enables us to achieve these goals. A consistent hashing algorithm enables us to map Cassandra row keys to physical nodes. The range of values from a consistent hashing algorithm is a fixed circular space which can be visualised as a ring. Consistent hashing also minimises the key movements when nodes join or leave the cluster. On average only k/n keys need to be remapped where k is the number of keys and n is the number of slots (nodes). This is in stark contrast to most hashing algorithms where a change in the number of slots results in the need to remap a large number of keys.</li><li style=\"padding: 0px 0px 8px;\"><strong>Data Replication</strong>&nbsp;- Partitioning of data on a shared nothing system results in a single point of failure i.e. if one of the nodes goes down part of your data is unavailable. This limitation is overcome by creating copies of the data, know as replicas, thus avoiding a single point of failure. Storing copies of data on multiple nodes is referred to as replication. &nbsp;Replication of data ensures fault tolerance and reliability.</li><li style=\"padding: 0px 0px 8px;\"><strong>Eventual Consistency</strong>&nbsp;- Since data is replicated across nodes we need to ensure that data is synchronized across replicas. This is referred to as data consistency. &nbsp;Eventual consistency is a consistency model used in distributed computing. It theoretically guarantees that, provided there are no new updates, all nodes/replicas will eventually return the last updated value. Domain Name System (DNS) are a good example of an eventually consistent system.</li><li style=\"padding: 0px 0px 8px;\"><strong>Tunable Consistency -&nbsp;</strong>Cassandra provides tunable consistency i.e. users can determine the consistency level by tuning it via read and write operations. Eventual consistency often conjures up fear and doubt in the minds of application developers. The key thing to keep in mind is that reaching a consistent state often takes microseconds.</li><li style=\"padding: 0px 0px 8px;\"><strong>Consistency Level</strong>&nbsp;- Cassandra enables users to configure the number of replicas in a cluster that must acknowledge a read or write operation before considering the operation successful. The consistency level is a required parameter in any read and write operation and determines the exact number of nodes that must successfully complete the operation before considering the operation successful.</li><li style=\"padding: 0px 0px 8px;\"><strong>Data Centre, Racks, Nodes</strong>&nbsp;- A Data Centre (DC) is a centralised place to house computer and networking systems to help meet an organisation's information technology needs. A rack is a unit that contains multiple servers all stacked one on top of another. A rack enables data centres to conserve floor space and consolidates networked resources. A node is a single server in a rack. Why do we care? Often Cassandra is deployed in a DC environment and one must replicate data intelligently to ensure no single point of failure. Data must be replicated to servers in different racks to ensure continued availability in the case of rack failure. Cassandra can be easily configured to work in a multi DC environment to facilitate fail over and disaster recovery.</li><li style=\"padding: 0px 0px 8px;\"><strong>Snitches and Replication Strategies</strong>&nbsp;- As mentioned above it is important to intelligently distribute data across DC’s and racks. In Cassandra the distribution of data across nodes is configurable. Cassandra uses snitches and replication strategies to determine how data is replicated across DC’s, racks and nodes. Snitches determine proximity of nodes within a ring. Replication strategies use proximity information provided by snitches to determine locality of a particular copy.</li><li style=\"padding: 0px 0px 8px;\"><strong>Gossip Protocol</strong>&nbsp;- Cassandra uses a gossip protocol to discover node state for all nodes in a cluster. &nbsp;Nodes discover information about other nodes by exchanging state information about themselves and other nodes they know about. This is done with a maximum of 3 other nodes. Nodes do not exchange information with every other node in the cluster in order to reduce network load. They just exchange information with a few nodes and over a period of time state information about every node propagates throughout the cluster. The gossip protocol facilitates failure detection.</li><li style=\"padding: 0px 0px 8px;\"><strong>Bloom Filters</strong>&nbsp;- &nbsp;A bloom filter is an extremely fast way to test the existence of a data structure in a set. A bloom filter can tell if an item might exist in a set or definitely does not exist in the set. False positives are possible but false negatives are not. Bloom filters are a good way of avoiding expensive I/O operation.</li><li style=\"padding: 0px 0px 8px;\"><strong>Merkle Tree</strong>&nbsp;- Merkle tree is a hash tree which provides an efficient way to find differences in data blocks. Leaves contain hashes of individual data blocks and parent nodes contain hashes of their respective children. This enables efficient way of finding differences between nodes.</li><li style=\"padding: 0px 0px 8px;\"><strong>SSTable</strong>&nbsp;- A Sorted String Table (SSTable) ordered immutable key value map. It is basically an efficient way of storing large sorted data segments in a file.</li><li style=\"padding: 0px 0px 8px;\"><strong>Write Back Cache</strong>&nbsp;- A write back cache is where the write operation is only directed to the cache and completion is immediately confirmed. This is different from Write-through cache where the write operation is directed at the cache but is only confirmed once the data is written to both the cache and the underlying storage structure.</li><li style=\"padding: 0px 0px 8px;\"><strong>Memtable</strong>&nbsp;- A memtable is a write back cache residing in memory which has not been flushed to disk yet.</li><li style=\"padding: 0px 0px 8px;\"><strong>Cassandra Keyspace</strong>&nbsp;- Keyspace is similar to a schema in the RDBMS world. A keyspace is a container for all your application data. When defining a keyspace, you need to specify a replication strategy and a replication factor i.e. the number of nodes that the data must be replicate too.</li><li style=\"padding: 0px 0px 8px;\"><strong>Column Family</strong>&nbsp;- A column family is analogous to the concept of a table in an RDBMS. But that is where the similarity ends. Instead of thinking of a column family as RDBMS table think of a column family as a map of sorted map. A row in the map provides access to a set of columns which is represented by a sorted map. &nbsp;<span style=\"line-height: 1.45em;\"><span style=\"font-family: Menlo, Monaco, monospace, sans-serif; font-size: 13.5px; white-space: pre; background-color: rgb(248, 248, 248);\">Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt; </span><span style=\"font-size: 15px; background-color: initial;\">Please note in CQL (Cassandra Query Language) lingo a Column Family is referred to as a table.</span></span><br></li><li style=\"padding: 0px 0px 8px;\"><strong>Row Key</strong>&nbsp;- A row key is also known as the partition key and has a number of columns associated with it i.e. a sorted map as shown above. The row key is responsible for determining data distribution across a cluster.</li></ul><h2 style=\"font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-weight: 600; line-height: 1.2; color: rgb(38, 38, 38); margin-top: 20px; margin-bottom: 5px; font-size: 30px; clear: both;\">Cassandra Cluster/Ring</h2><h3 style=\"font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; line-height: 1.2; color: rgb(38, 38, 38); margin-top: 20px; margin-bottom: 5px; font-size: 25px; clear: both;\">Cluster Bootstrapping</h3><p pid=\"2\" style=\"margin-top: 5px; margin-bottom: 15px; padding-top: 0px; color: rgb(38, 38, 38); font-family: Georgia, serif; font-size: 19px; line-height: 27.55px;\">Every Cassandra cluster must be assigned a name. All nodes participating in a cluster have the same name. Seed nodes are used during start up to help discover all participating nodes. Seeds nodes have no special purpose other than helping bootstrap the cluster using the gossip protocol. When a node starts up it looks to its seed list to obtain information about the other nodes in the cluster. Cassandra uses the gossip protocol for intra cluster communication and failure detection. A node exchanges state information with a maximum of three other nodes. State information is exchanged every second and contains information about itself and all other known nodes. &nbsp;This enables each node to learn about every other node in the cluster even though it is communicating with a small subset of nodes.</p><div><br></div><img src=\"http://dev-coe-cp.cloudapp.net:51005/alfresco/s/collab-services/content?guest=true&amp;dir=collab-services-dev&amp;fname=f25_CFSmodel-1.png\">",
  "author": null,
  "blog_id": "blog_mock_1",
  "status": "PUBLISHED",
  "viewed_by": [],
  "tags": ["cassandra", "nosql"],
  "liked_by": [],
  "comments": [],
  "dateOfPublishing": "2016-06-17T16:25:24.290Z"
}