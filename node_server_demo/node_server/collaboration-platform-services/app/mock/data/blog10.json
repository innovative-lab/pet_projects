{
  "blog_id": "blog_mock_10",
  "title": "Basics of Spring Boot",
  "author": null,
  "content": "<p>After working on Play Framework for quite some time and then writing REST based web-service using Spring Boot, I was expecting my development productivity to reduce since I would be spending most of my time in configurations and writing boilerplate code (which was the case with before Spring Boot) rather than concentrating on the actual business logic. But I was amazed by the maturity and ease with which Spring Boot has radically improved developer's experience to build production-ready Spring application in short span of time. Thanks to its convention over configuration mechanism which allows Spring Boot to preconfigure applications in an opinionated way whenever possible. Spring Boot also comes with various modules which provides easy to set up facility with minimum time. Some widely used modules are - spring-boot, spring-boot-starters, spring-boot-actuator, etc. Spring Boot encapsulates a wide range of Spring features from the developers and presents them with a smaller view to concentrate on specific areas, thereby handling most of the complex activities underneath. <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2016/01/spring-boot-intro-img.png\"><img class=\"aligncenter wp-image-5334 size-full\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2016/01/spring-boot-intro-img.png\" alt=\"spring boot intro img\" width=\"325\" height=\"449\" /></a> Creating a new Spring Application is as easy as opening Spring Initializer page - <a href=\"http://start.spring.io/\">http://start.spring.io/</a> , specifying metadata and dependencies required by the project and then click <strong>Generate Project</strong>. Done! This will create a new Spring project. You can now import it in your preferred IDE, build and run it without any initial configuration. Isn't it very simple? <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2016/01/spring-initializer.png\"><img class=\"alignnone size-full wp-image-5330\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2016/01/spring-initializer.png\" alt=\"spring initializer\" width=\"742\" height=\"634\" /></a>   <span style=\"font-size: 18pt;\"><strong>Key Features -</strong></span> <strong>1&#46;</strong> <strong>Build Systems -</strong> Supports both Maven and Gradle. <strong>2&#46;</strong> <strong>pom.xml -</strong> Spring Boot provides many Starter Dependencies. On specifying these dependencies, it automatically brings all needed dependencies to your project. Like, <strong>spring-boot-starter-parent</strong> which is a special starter that provides useful Maven defaults. <em>                 <parent></em> <em>                                <groupId>org.springframework.boot</groupId></em> <em>                                <artifactId>spring-boot-starter-parent</artifactId></em> <em>                                <version>1.2.5.RELEASE</version></em> <em>                                <relativePath/> <!-- lookup parent from repository --></em> <em>                </parent></em> Similarly, if you want to create a Spring web application you can include <strong>spring-boot-starter-web</strong> starter and you are ready to write your code. <em>                <dependency></em> <em>                                <groupId>org.springframework.boot</groupId></em> <em>                                <artifactId>spring-boot-starter-web</artifactId></em> <em>                </dependency></em> At any point (mostly while resolving conflicts) if you want to see the dependencies that are loaded, you can use <strong>mvn dependency:tree</strong> or <strong>mvn dependency:tree -Dverbose</strong> (with verbose flag to display conflicting dependencies that were omitted from the resolved dependency tree). <strong>3&#46;</strong> <strong>application.properties -</strong> Spring Boot has given various options to externalize your configurations like properties file, YAML file, environment variables, command-line arguments, environment-specific configurations, etc. By default, Spring Boot searches for application.properties file in your application classpath or current directory and loads the configurations to the Spring Environment. We can then easily read the properties by autowiring <strong>Environment</strong> as below and using getProperty() to read a specific properties file. <em>                  @Autowired</em> <em>                  private Environment env;</em> <em>                 //Read property value using getProperty()</em> <em>                 env.getProperty(\"<property-key>\")</em> Another simple way to read properties from configuration files using <strong>@Value</strong> annotation. If you want to rename application.properties to some other file name, you add that configuration file (sample-boot.properties) in your project and access it by specifying <strong>spring.config.name</strong> environment property while starting the application as below. <strong><em>                > java -jar sample-boot-project.jar --spring.config.name=sample-boot</em></strong> <strong>4&#46;</strong> <strong>Profiles -</strong> Spring Boot helps us to provide environment-specific configuration files in the simplest way. We just have to add a class, annotate it with <strong>@Configuration</strong> and <strong>@Profile</strong> and specify profile name to load environment specific configuration file. application.properties also enables us to externalize configurations and use them with the same application code but with different environment. This can be done using profile-specific configuration files. This means that if you want to load configurations for \"<em>dev</em>\" environment, add a configuration file with name - <strong>application-dev.properties</strong> and start application by specifying active profile using - <strong>                   spring.profiles.active=dev.</strong> If required, other configuration files (specific to some integration points or application or environment) can be added in a Spring Boot application by defining a configuration class as below. <em>                   @Configuration</em> <em>                   @Profile(\"test\")</em> <em>                   @PropertySource({ \"classpath:config-test.properties\", \"classpath:error_message.properties\"})</em> <em>                   public class AppConfig {</em> <em>                   public AppConfig() {</em> <em>                      }</em> <em>                  }</em> The above class uses <strong>@Profile</strong> annotation to specify that Spring Boot to load <strong>test **environment-specific configuration files. These configuration files can be specified under **@PropertySource</strong> annotation. <strong>5&#46;</strong> <strong>Embedded Servers -</strong> Spring Boot comes with options of embedded servlet containers like Tomcat, Jetty, etc. which makes it easier to develop a standalone application, package it as a jar and deploy it using java -jar option. Spring Boot starters (spring-boot-starter-web in particular) use Tomcat as an embedded container by default. But other containers can also be configured explicitly. <strong>6&#46;</strong> <strong>Monitoring –</strong> Using <strong>spring-boot-starter-actuator</strong>, some useful end-points gets exposed which could be used to monitor your application. Some of these end-points are as below – \n*   <strong>/autoconfig:</strong> Displays all auto-configuration candidates\n*   <strong>/beans:</strong> Displays a complete list of all the Spring beans in your application\n*   <strong>/configprops:</strong> Displays a collated list of all @ConfigurationProperties\n*   <strong>/dump:</strong> Performs a thread dump\n*   <strong>/env:</strong> Exposes properties from Spring’s ConfigurableEnvironment\n*   <strong>/health:</strong> Shows application health information with “status” attribute\n*   <strong>/info:</strong> Displays arbitrary application info\n*   <strong>/metrics:</strong> Shows ‘metrics’ information for the application like memory, processor, uptime, etc.\n*   <strong>/mappings:</strong> Displays a collated list of all @RequestMapping paths\n*   <strong>/shutdown:</strong> Allows the application to be gracefully shutdown (not enabled by default)\n*   <strong>/trace:</strong> Displays trace information (by default the last few HTTP requests) Spring Boot has simplified the way Spring can be used. It has radically enhanced development experience using Spring framework. Some of the cool features like health-checks, easy external configuration, embedded servers, metrics, etc. has given a wide acceptance to Spring Boot. If you have not yet tried it out, you are missing some interesting stuff. In that case I would encourage you to go ahead and give it a try !! Watch out this space for few more interesting blogs on Spring Boot.</p>\n",
  "status": "PUBLISHED",
  "viewed_by": [],
  "tags": ["microservices", "spring"],
  "liked_by": [],
  "comments": [],
  "dateOfPublishing": "2016-06-17T16:25:24.321Z"
}