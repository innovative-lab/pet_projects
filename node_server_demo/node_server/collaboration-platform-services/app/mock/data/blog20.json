{
  "blog_id": "blog_mock_20",
  "title": "Erlang Programming Language",
  "author": null,
  "content": "<p style=\"text-align: justify;\">\n  <span style=\"font-size: 24pt;\">E</span>rlang programming language was originally designed and developed to meet needs of systems in Telecom sector. These systems are supposed to be soft-real-time, fault tolerant, scalable and highly available. Erlang not only supports these features but has simplified and efficient way of implementing them.\n</p>\n\n<p style=\"text-align: justify;\">\n  Erlang is described as functional programming language and has some inherited characteristics of functional language such as pattern matching, single assignment, higher-order functions, list comprehensions. Functional languages are comprised primarily of functions. Because there is no global location (variable) in program program's state is not maintained across function calls. As a result output of any function depends only on the arguments passed to it. Functions can be bound to a variable, passed as a parameter or received as return value from a function. Single assignment is one of the interesting characteristics of functional languages where any variable can be bound to a value only once. The value of a variable cannot be changed. Due to this a loop in program is implemented using recursion and any state values (like counter) have to be passed as arguments in recursive calls. Pattern matching forms the basis for programming in these languages. In Erlang pattern matching is used to bind values to variables, control the execution flow of programs and extract values from compound data structures.\n</p>\n\n<p style=\"text-align: justify;\">\n  In Erlang concurrency is achieved using processes. Erlang provides language-level features for creating and managing processes with the aim of simplifying concurrent programming. Erlang processes run independently in VM. They communicate with each other using message passing. Processes are identified and managed by their ids (called as pid) or registered names. They don’t share any memory space among themselves which removes the need of locks. Processes in Erlang are lightweight. Their creation time is very less and independent of number of running processes. They are created, scheduled and handled in the VM. The number of OS threads used by Erlang VM depends on number of processors (cores) unlike Java and C# where a separate native OS thread is created and assigned to each Java/C# thread. With SMP (Symmetrical Multi Processor) support all OS threads run on different cores thus making use of multi-core processors. Each OS thread (or each core) has a process-run queue and a scheduler which schedules Erlang processes from the queue to run as OS thread.\n</p>\n\n<p style=\"text-align: justify;\">\n  In distributed programming with Erlang an Erlang runtime system is called as node. In a distributed system the default communication mode is TCP/IP. A node can connect to any other node from heterogeneous network, running on any operating system. Once connected processes from different nodes can also communicate with other. The syntax of sending message to local process (running on same node) is the same as sending to remote process (running on different node). Processes can use their globally registered names to identify each other. This makes the process distribution transparent. As distribution is built into the language, clustering, load balancing, scalability, communication and reliability come with very little overhead and correspondingly little code.\n</p>\n\n<p style=\"text-align: justify;\">\n  OTP (Open Telecom Platform) is framework with set of libraries and design specifications which helps in building robust and fault tolerant systems. These libraries capture the generic behaviors of popular architecture models, letting developer deal with only specific behavior. This minimizes developer's job and makes error/fault detection simpler. OTP framework provides some behaviors such as gen_server, supervisor, application, gen_event, gen_fsm. Each behavior provides the generic behavior for some model. For example gen_server captures all the generic behavior of the client-server model (one server, many clients), supervisor provides generic behavior of supervisor-worker model (one supervisor, many workers), etc. Application behavior is used to bundle all Erlang modules into one Erlang application which can be started, stopped as a unit or reused as a software component.\n</p>\n\n<p style=\"text-align: justify;\">\n  Erlang standard distribution provides virtual machine as runtime as well as some development tools, OTP framework. Development tools include shell, compiler, debugger, profiler and test framework. Erlang's modules get compiled to byte code (beam files) and run inside virtual machine.\n</p>\n\n<p style=\"text-align: justify;\">\n  If there is requirement to build a high-level, concurrent, robust, highly available, soft real-time system that will scale linearly, make full use multi-core processors and integrate with components written in other languages Erlang will be the best fit for it. But Erlang shouldn’t be the choice if you are writing a computation intensive, a number-crunching application, a client software for mobiles or a graphics intensive system.\n</p>\n",
  "status": "PUBLISHED",
  "viewed_by": [],
  "tags": ["erlang", "functional", "programming"],
  "liked_by": [],
  "comments": [],
  "dateOfPublishing": "2016-06-17T16:25:24.353Z"
}