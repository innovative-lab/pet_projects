{
  "blog_id": "blog_mock_15",
  "title": "Let’s play with Play framework!",
  "author": null,
  "content": "<p>While I was coding in Scala, I came across Play framework for developing web-applications using Scala. I started developing a REST-based web service using Play and Scala and I was utterly impressed by the numerous features provided by Play by default. In this blog, I would be sharing some of those attractive features that were explored by me and which has increased the popularity of Play framework and has taken web application development to a different level. Play is an open-source web-application framework for writing scalable web applications in Java and Scala. It follows Model-View-Controller (MVC) design pattern. It aims at rapid application development and drastically improves developer's productivity. Ex: - It displays error messages (if any) during page reloads in the browser, allows hot deployment (no need to deploy and restart server multiple times), etc. Play has gained enormous attention in the IT industry now-a-days for its focus on building reactive and modern web applications and usability of Java and Scala.   <strong>Play Architecture</strong> Play applications follow the MVC architectural pattern applied to the web architecture. \n*   **Model- **the domain-specific representation of the information on which the application operates.\n*   **View - **renders the model in a suitable form for user interactions\n*   **Controller - **receives user request, processes them (by invoking changes in the model) and sends the response to view (for rendering). In a Play application, these layers are defined in the “</p>\n\n<p><em>app”</em> directory as “<em>app/models</em>”, “<em>app/views</em>” and “<em>app/controllers</em>”. <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/architecture.png\"><img class=\"aligncenter  wp-image-5016\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/architecture.png\" alt=\"architecture\" width=\"679\" height=\"426\" /></a>   <strong>Why should one learn Play Framework?</strong> Play provides the following interesting features which makes it quite different from other existing web application frameworks and has attracted many developers to <em>play</em> with this framework. 1. <strong>Supports Java and Scala:</strong> Both Java and Scala can be used to develop web-applications in Play framework. 2. <strong>Async support and concurrency:</strong> Play provides asynchronous support using a powerful tool \"<em>Akka</em>\" for building highly concurrent and scalable applications. Play does not compromise with responsiveness due to any blocking operation. Instead, it provides \"<em>Future</em>\" and \"<em>Promise</em>\" which are by default non-blocking. They use callbacks instead of typical blocking operations and are used to perform many operations concurrently, results of which are collected at later point of time. 3. <strong>Easy datastore integration:</strong> With Play, it is really easy to use any data store driver, ORM or any other database access library without any special integration with the framework. Play also provides \"H2\" as in-memory database by default, but other databases can also be configured. Any other database configuration like maintaining connection pool, logging SQL statements, etc can be easily configured in \"<em>conf/application.conf</em>\" file as shown in the diagram below. <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/databaseConfiguration.png\"><img class=\"aligncenter  wp-image-5017\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/databaseConfiguration.png\" alt=\"databaseConfiguration\" width=\"599\" height=\"406\" /></a> Play also provides a facility to execute script on page refresh, which are termed as \"<em>evolution scripts</em>\" and are to be placed inside \"<em>conf/evolutions</em>\" directory. 4. <strong>Easy router mapping: **Play framework provides very good support for HTTP routing. HTTP router is responsible for translating each incoming request to an Action call. Routes are defined in “*conf/routes\" *file. Each route consist of an HTTP method and URI pattern, both are associated with a call to an Action generator. <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/routes.png\"><img class=\"aligncenter  wp-image-5019\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/routes.png\" alt=\"routes\" width=\"618\" height=\"183\" /></a> 5. **Fix the bug, hit refresh:</strong> Java web-application frameworks result in low productivity of developers because of its tedious and repeated compile-package-deploy cycle. But with Play framework, there is no need to re-compile, deploy or re-start of servers after you make any change. Just save the file and refresh your browser, you can see the changes immediately. In case of any compilation errors, the framework shows it directly in the browser along with the line number having the problem as shown below. <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/error.png\"><img class=\"aligncenter  wp-image-5020\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/error.png\" alt=\"error\" width=\"662\" height=\"253\" /></a> The framework also displays the entire stacktrace in the console to make it easier to solve the problem. 6. <strong>Stateless model:</strong> Most of Java web application frameworks use server-side session objects to store session, which complicates scaling. But, Play is based on \"*Share Nothing*\" architecture, in which no session is being managed at server end. Data is added to each subsequent HTTP request using Cookies, which means the data size is very limited (around 4KB) and can only store string values. Play has a new concept of \"*Flash Scope*\" in which data is kept for only one request. It is mostly used for transporting success/error messages. 7. <strong>Efficient dependency management:</strong> Play supports two ways of dependency management: *managed* and *unmanaged*. Play uses *Apache Ivy* (via sbt) to implement managed dependencies. For managed dependencies, you need to specify the dependencies in *build.sbt *file which is present in the root of the project. Multiple dependencies can be specified in build.sbt as below. <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/DependencyMgmt.png\"><img class=\"aligncenter  wp-image-5021\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/10/DependencyMgmt.png\" alt=\"DependencyMgmt\" width=\"496\" height=\"217\" /></a> For unmanaged dependencies, you need to create a \"lib\" directory in the root of your project and add the jar files to this directory. 8. <strong>Easy to write REST APIs:</strong> Play is fundamentally a framework for writing REST APIs. Its efficient HTTP routing, JSON marshalling/unmarshalling API, etc has made it very easy to write RESTful applications using Play framework.   Play frameworks seems interesting and promising, isn’t it?? Checkout the blog's space to see some more blogs coming up on Play.  </p>\n",
  "status": "PUBLISHED",
  "viewed_by": [],
  "tags": ["play", "reactive"],
  "liked_by": [],
  "comments": [],
  "dateOfPublishing": "2016-06-17T16:25:24.337Z"
}