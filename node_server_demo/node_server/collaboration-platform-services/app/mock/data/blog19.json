{
  "blog_id": "blog_mock_19",
  "title": "Stress Tool",
  "author": null,
  "content": "<p><strong>STRESS TOOL</strong> Stress Tool is a command line tool which generates performance report of application in tabular format for given number of users and load. <strong>Purpose of Stress Tool</strong> Scalability is a major concern and an important NFR always. The application performance is to be assessed by simulating concurrent users and huge amount of load. Stress tool serves the purpose of generating required load and concurrent users and provide useful reports, no matter what is being tested because it provides users the freedom to select what they want to test. <strong>Structural Diagram</strong> <a href=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/08/stress.png\"><img class=\"alignnone size-medium wp-image-4875\" src=\"https://vista-mindtree.cloudapp.net/coe_open/wp-content/uploads/2014/08/stress-300x88.png\" alt=\"stress\" width=\"300\" height=\"88\" /></a>   Stress tool need to have two components – Core and Runner. Stress core is the framework which does execution of the workers and processors. Stress core provides the hooks for preprocessor, worker and postprocessor as interfaces, which are to be implemented in the stress core runner. The intent of preprocessor is to perform the task which should be done before the real load test. It can be compare to setup() of unit testing. Workers are the main tasks for which the core measures the performance. Postprocessors can be the set of tasks which are to be performed after the main task and before closing the application. This can be compared to teardown() of unit testing. The preprocessors and the workers are implemented in runner by user. Runner is the user implementation to test the real system. For example, if you want to test your DB performance – inject your DAOs in the worker implementation. If you want to test your REST WS – inject your proxies to the worker implementation. In Stress Core Runner, preprocessor implementation can include getting the required data and validation of any VM arguments etc., before starting the execution of the workers. Actual implementation of preparing request and triggering an application is to be included in the worker implementation. The load will be distributed across the workers according to the input command line arguments. Postprocessor implementation can include cleanup of resources. <strong>How Stress Core works</strong> Stress is the main executable class in stress-core that is to be invoked with few mandatory parameters like load, ratio and threads. User can use some system parameters with “-D” if they needs something in implementation to come from command line. Once the execution starts, first all the preprocessors will be executed in the user defined sequence. Then according to the load, ratio and thread work will be distributed between workers. For example if the ratio is 20:20:60 and load is 1000 and threads are 200, then 200 threads will be created to trigger the three workers where first worker will send 200 requests, second worker will send 200 requests and third worker will send 600 requests. Yes!! As you have mentioned 3 components of ratio, there must be 3 workers. Example for this can be – you want to test create, update and retrieve flow in ratio of 20, 20 and 60 respectively, then you need a CreateWorker, UpdateWorker and RetrieveWorker. In the end of the execution a report will be generated in CSV format. This is raw data which user can use to generate various reports as per his requirements. <strong>Performance report</strong> This stress tool generates the csv file with options such as <em>timestamp of report row generation, number of threads, number of load, total time taken, transactions per second, and execution count of each worker</em> in that run. <strong>Usage and things to watch</strong> This tool can be used anywhere, if the requirement is to do the stress test on a given component. The component can be anything – DB, WS, EJB calls, queues. Name anything and you can test that for a load. You need to inject that in the worker implementation. The bare bone core with blank implementation of processors and workers, with load of 1 million with 200 threads on a 4 core i5 processor with 8GB RAM can produce up to 10 million transactions per second (TPS). If you need more concurrent users than 200, you need to tune the JVM accordingly. Currently the tools does not provide the distributed load testing, hence you need to do it manually i.e. run the tool from different client machines to hit the component you are testing under load. For more details download the stress tool from <a href=\"/coe_open/mrald/\">Mrald</a> and look into its documentation or contact <a href=\"mailto:openplatform_coe@mindtree.com\">Open platform</a>.   <strong> </strong>  </p>\n",
  "status": "PUBLISHED",
  "viewed_by": [],
  "tags": ["testing", "performance"],
  "liked_by": [],
  "comments": [],
  "dateOfPublishing": "2016-06-17T16:25:24.353Z"
}